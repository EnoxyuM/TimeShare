<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TimeShare</title>
    <style>
        :root { --cell-size: 35px; }

        body {
            background-color: #2c2c2c; color: #e0e0e0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            display: flex; justify-content: center; align-items: center; height: 100vh;
            margin: 0; padding: 10px; box-sizing: border-box; user-select: none; -webkit-user-select: none; overflow: hidden;
        }
        .main-layout { display: flex; gap: 20px; align-items: center; width: 100%; height: 100%; justify-content: center; }
        .schedule-container {
            flex-shrink: 0; padding: 15px; background-color: #333; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            height: 100%; max-height: calc(100vh - 20px); display: flex; flex-direction: column;
            overflow-x: auto;
        }
        .schedule-wrapper {
            display: flex;
            gap: 20px;
            height: 100%;
        }
        .week-grid {
            display: grid;
            gap: 2px;
            grid-template-columns: 50px repeat(7, var(--cell-size));
            grid-template-rows: auto repeat(24, var(--cell-size));
        }

        .grid-cell { display: flex; justify-content: center; align-items: center; }
        .day-header { font-weight: bold; text-transform: uppercase; padding: 2px 0; flex-direction: column; line-height: 1.2; font-size: 13px; }
        .day-header.current-day { color: #5a9ced; }
        .day-header.current-day .date-number { color: #5a9ced; font-weight: bold; }
        .day-header .date-number { font-size: 12px; font-weight: normal; color: #aaa; }
        .time-label { font-size: 11px; color: #aaa; justify-content: flex-end; padding-right: 8px; }
        
        .hour-cell {
            background-color: #38761d; cursor: pointer; transition: background-color 0.2s, color 0.2s;
            font-size: 14px; font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #000;
            text-shadow: -1px -1px 0 #fff, 1px -1px 0 #fff, -1px 1px 0 #fff, 1px 1px 0 #fff;
        }

        .hour-cell.no-edit { cursor: default; }
        .hour-cell:hover { filter: brightness(1.2); }
        .hour-cell.selected { background-color: #cc0000; }
        .hour-cell.unknown-tz { background-color: #D87093; cursor: default; }


        .sidebar { padding: 20px; background-color: #333; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.4); min-width: 250px; display: flex; flex-direction: column; align-self: flex-start; }
        .sidebar .controls { border-bottom: 1px solid #444; padding-bottom: 15px; margin-bottom: 15px; }
        .sidebar label { display: block; font-size: 14px; color: #bbb; margin-bottom: 8px; }
        .sidebar input, .sidebar select { width: 100%; padding: 8px; margin-bottom: 16px; box-sizing: border-box; background-color: #444; border: 1px solid #666; border-radius: 4px; color: #e0e0e0; font-size: 16px; }
        .sidebar input:focus, .sidebar select:focus { outline: none; border-color: #5a9ced; }
        .sidebar .tz-warning { font-size: 12px; color: #999; margin: 0 0 10px 0; line-height: 1.4; }
        .sidebar .button-group { display: flex; gap: 10px; margin-top: 8px;}
        .sidebar button { flex-grow: 1; padding: 10px; font-size: 14px; font-weight: bold; color: #fff; border: none; border-radius: 4px; cursor: pointer; transition: background-color 0.2s; }
        #copy-btn { background-color: #007bff; }
        #copy-btn:hover { background-color: #0056b3; }
        #paste-btn { background-color: #28a745; }
        #paste-btn:hover { background-color: #1e7e34; }
        #feedback-message { margin-top: 15px; text-align: center; font-size: 14px; color: #aaa; height: 20px; opacity: 0; transition: opacity 0.3s ease-in-out; }
        #feedback-message.show { opacity: 1; }
        .user-list-container { display: flex; flex-direction: column; gap: 8px; }
        .user-list-container .user-item, .user-list-container .view-item { display: flex; flex-direction: column; gap: 8px; }
        .user-list-container .user-item .user-controls { display: flex; align-items: center; gap: 8px; }
        .user-list-container button { width: 100%; text-align: left; background-color: #4f4f4f; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .user-list-container button:hover { background-color: #5f5f5f; }
        .user-list-container button.active { background-color: #007bff; }
        .user-list-container .delete-btn {
            background-color: transparent; border: none; color: #aaa; font-size: 22px; font-weight: bold; cursor: pointer;
            line-height: 1; flex-shrink: 0; width: 24px; height: 24px; padding: 0; display: flex; align-items: center; justify-content: center;
        }
        .user-list-container .delete-btn:hover { color: #ff6b6b; }
        #threshold-select { margin-top: 8px; font-size: 14px; padding: 6px; }

        #instruction-btn {
            position: absolute; top: 15px; left: 15px; z-index: 100;
            background-color: #4f4f4f; padding: 8px 12px;
        }
        #instruction-btn:hover { background-color: #5f5f5f; }

        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex; justify-content: center; align-items: center;
            z-index: 999; opacity: 0; pointer-events: none;
            transition: opacity 0.3s ease;
        }
        .modal-overlay.visible { opacity: 1; pointer-events: auto; }
        .modal-content {
            background-color: #333; color: #e0e0e0;
            padding: 25px; border-radius: 8px;
            max-width: 600px; width: 90%;
            box-shadow: 0 5px 20px rgba(0,0,0,0.5);
            position: relative;
        }
        .modal-content h2 { margin-top: 0; color: #5a9ced; }
        .modal-content p, .modal-content li { line-height: 1.6; }
        .modal-content strong { color: #e0e0e0; }
        .modal-close-btn {
            position: absolute; top: 10px; right: 15px;
            font-size: 28px; font-weight: bold; color: #aaa;
            background: none; border: none; cursor: pointer;
        }
        .modal-close-btn:hover { color: #fff; }
    </style>
</head>
<body>

<button id="instruction-btn">Инструкция</button>
<div class="modal-overlay" id="modal-overlay">
    <div class="modal-content">
        <button class="modal-close-btn" id="modal-close-btn">&times;</button>
        <h2>Инструкция</h2>
        <p>Зажимая ЛКМ/ПКМ по ячейкам окрасьте их в красный/зелёный чтобы составить расписание(занят/свободен).</p>
        <p>Используйте именно ваше время, а не например Московское(если вы конечно сами не в Москве).</p>
        <p>Затем нажмите "Копировать"(скопирует сжатую строку расписания в буфер обмена) и перешлите созданное расписание другим.</p>
        <h4>Открытие/Вставка чужих расписаний:</h4>
        <p>"Вставить" вставит скопированное расписание добавив имя по которому можно кликнуть для просмотра.</p>
        <p>Расписание отобразится скорректировавшись под ваше время(GMT).</p>
        <p>Вставив так несколько расписаний, на кнопку "Все" можно просматривать общие свободные часы, а список ниже поможет отфильтровать часы в которые свободны все или почти все.</p>
    </div>
</div>

<div class="main-layout">
    <div class="schedule-container" id="schedule-container">
        <div class="schedule-wrapper" id="schedule-wrapper"></div>
    </div>
    <div class="sidebar">
        <div class="controls">
            <label for="nickname-input">Мой ник:</label>
            <input type="text" id="nickname-input" placeholder="Введите ваш ник...">

            <label for="timezone-select">Ваш часовой пояс:</label>
            <p class="tz-warning">Помните: чужие расписания корректируются с выбранным часовым поясом:</p>
            <select id="timezone-select"></select>

            <div class="button-group">
                <button id="copy-btn">Копировать</button>
                <button id="paste-btn">Вставить</button>
            </div>
            <div id="feedback-message"></div>
        </div>
        <div class="user-list-container" id="user-list-container"></div>
    </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {

    let users = []; 
    let activeView = '__MY_SCHEDULE__';
    let overlapThreshold = 'all'; // 'all' или число
    const WEEKS_TO_SHOW = 3;
    const DAYS_PER_WEEK = 7;
    const HOURS_PER_DAY = 24;
    const CELLS_PER_WEEK = DAYS_PER_WEEK * HOURS_PER_DAY;
    const TOTAL_DAYS = WEEKS_TO_SHOW * DAYS_PER_WEEK;
    const TOTAL_CELLS = TOTAL_DAYS * HOURS_PER_DAY;

    const scheduleContainer = document.getElementById('schedule-container');
    const scheduleWrapper = document.getElementById('schedule-wrapper');
    const nicknameInput = document.getElementById('nickname-input');
    const copyBtn = document.getElementById('copy-btn');
    const pasteBtn = document.getElementById('paste-btn');
    const feedbackMessage = document.getElementById('feedback-message');
    const userListContainer = document.getElementById('user-list-container');
    const instructionBtn = document.getElementById('instruction-btn');
    const modalOverlay = document.getElementById('modal-overlay');
    const modalCloseBtn = document.getElementById('modal-close-btn');
    const timezoneSelect = document.getElementById('timezone-select');

    instructionBtn.addEventListener('click', () => modalOverlay.classList.add('visible'));
    modalCloseBtn.addEventListener('click', () => modalOverlay.classList.remove('visible'));
    modalOverlay.addEventListener('click', (e) => { if (e.target === modalOverlay) modalOverlay.classList.remove('visible'); });
    timezoneSelect.addEventListener('change', render);

    function populateTimezoneSelector() {
        const detectedOffset = new Date().getTimezoneOffset() / -60;
        for (let i = 14; i >= -12; i -= 0.5) {
            const option = document.createElement('option');
            const sign = i >= 0 ? '+' : '-';
            const absI = Math.abs(i);
            const hours = Math.floor(absI).toString().padStart(2, '0');
            const minutes = (absI % 1 !== 0) ? '30' : '00';
            option.value = i;
            option.textContent = `GMT${sign}${hours}:${minutes}`;
            timezoneSelect.appendChild(option);
        }
        timezoneSelect.value = detectedOffset;
    }

    function getGradientColor(freeCount, totalUsers) {
        if (totalUsers <= 1) return freeCount === 1 ? 'rgb(0, 255, 0)' : '#1c1c1c';
        if (freeCount === 0) return '#1c1c1c';
        const t = (freeCount - 1) / (totalUsers - 1);
        const r = Math.round(255 * (1 - t));
        const g = Math.round(255 * t);
        return `rgb(${r}, ${g}, 0)`;
    }

    function renderUserList() {
        userListContainer.innerHTML = '';

        const clearItem = document.createElement('div'); clearItem.className = 'view-item';
        const clearBtn = document.createElement('button'); clearBtn.textContent = 'Очистить';
        if (activeView === '__MY_SCHEDULE__') clearBtn.classList.add('active');
        clearBtn.onclick = () => {
            scheduleWrapper.querySelectorAll('.hour-cell.selected').forEach(cell => cell.classList.remove('selected'));
            nicknameInput.value = '';
            activeView = '__MY_SCHEDULE__';
            render();
        };
        clearItem.appendChild(clearBtn); userListContainer.appendChild(clearItem);

        const allItem = document.createElement('div'); allItem.className = 'view-item';
        const allBtn = document.createElement('button');
        allBtn.textContent = `Все(${users.length})`;
        if (activeView === '__ALL__') allBtn.classList.add('active');
        allBtn.onclick = () => { 
            activeView = '__ALL__'; 
            overlapThreshold = 'all';
            render(); 
        };
        allItem.appendChild(allBtn);

        if (users.length > 2) {
            const thresholdSelect = document.createElement('select');
            thresholdSelect.id = 'threshold-select';
            
            const allOption = document.createElement('option');
            allOption.value = 'all';
            allOption.textContent = 'Все (градиент)';
            thresholdSelect.appendChild(allOption);

            for (let i = users.length; i >= 2; i--) {
                const option = document.createElement('option');
                option.value = i;
                option.textContent = `Свободны ${i} и более`;
                thresholdSelect.appendChild(option);
            }
            thresholdSelect.value = overlapThreshold;

            thresholdSelect.onchange = (e) => {
                overlapThreshold = e.target.value;
                activeView = '__ALL__';
                render();
            };
            allItem.appendChild(thresholdSelect);
        }

        userListContainer.appendChild(allItem);

        users.forEach(user => {
            const userItem = document.createElement('div'); userItem.className = 'user-item';
            const userControls = document.createElement('div'); userControls.className = 'user-controls';

            const userBtn = document.createElement('button'); userBtn.textContent = user.nickname;
            if (activeView === user.nickname) userBtn.classList.add('active');
            userBtn.onclick = () => { activeView = user.nickname; render(); };
            
            const deleteBtn = document.createElement('button'); deleteBtn.className = 'delete-btn'; deleteBtn.innerHTML = '&times;';
            deleteBtn.onclick = () => { 
                users = users.filter(u => u.nickname !== user.nickname); 
                if(activeView === user.nickname) activeView = '__MY_SCHEDULE__'; 
                if (users.length <= 2) overlapThreshold = 'all';
                render(); 
            };

            userControls.appendChild(userBtn); 
            userControls.appendChild(deleteBtn);
            userItem.appendChild(userControls);
            userListContainer.appendChild(userItem);
        });
    }

    function renderGrid() {
        const hourCells = Array.from(scheduleWrapper.querySelectorAll('.hour-cell'));
        const isEditMode = activeView === '__MY_SCHEDULE__';
        hourCells.forEach(cell => { 
            cell.classList.toggle('no-edit', !isEditMode);
            cell.classList.remove('selected', 'unknown-tz');
            cell.style.backgroundColor = '';
            cell.textContent = '';
        });
        const viewerOffsetHours = parseFloat(timezoneSelect.value);

        if (isEditMode) {
        } else if (activeView === '__ALL__') {
            const totalUsers = users.length;
            if (totalUsers === 0) return;

            const busyCounts = new Array(TOTAL_CELLS).fill(0);
            const isUnknownCell = new Array(TOTAL_CELLS).fill(false);

            users.forEach(user => {
                const hourShift = viewerOffsetHours - user.senderOffsetHours;
                const scheduleStateArray = getShiftedScheduleState(user.originalScheduleBytes, hourShift);

                scheduleStateArray.forEach((state, i) => {
                    if (state === 1) {
                        busyCounts[i]++;
                    } else if (state === 2) {
                        busyCounts[i]++;
                        isUnknownCell[i] = true;
                    }
                });
            });

            hourCells.forEach((cell, i) => {
                const freeCount = totalUsers - busyCounts[i];
                
                if (isUnknownCell[i]) {
                    cell.classList.add('unknown-tz');
                    cell.textContent = '';
                    return;
                }

                if (overlapThreshold === 'all') {
                    cell.style.backgroundColor = getGradientColor(freeCount, totalUsers);
                    cell.textContent = freeCount > 0 ? freeCount : '';
                } else {
                    const threshold = parseInt(overlapThreshold, 10);
                    if (freeCount >= threshold) {
                        cell.style.backgroundColor = '#38761d'; // Green
                    } else {
                        cell.style.backgroundColor = '#cc0000'; // Red
                    }
                    cell.textContent = freeCount > 0 ? freeCount : '';
                }
            });

        } else {
            const user = users.find(u => u.nickname === activeView);
            if (!user) { activeView = '__MY_SCHEDULE__'; render(); return; }

            const hourShift = viewerOffsetHours - user.senderOffsetHours;
            const scheduleStateArray = getShiftedScheduleState(user.originalScheduleBytes, hourShift);
            
            hourCells.forEach((cell, i) => {
                const state = scheduleStateArray[i];
                if (state === 1) { // Busy
                    cell.classList.add('selected');
                } else if (state === 2) { // Unknown
                    cell.classList.add('unknown-tz');
                }
            });
        }
    }

    function render() { renderUserList(); renderGrid(); }

    function resizeGrid() { 
        const p = parseFloat(getComputedStyle(scheduleContainer).paddingTop) * 2;
        const h = scheduleContainer.clientHeight - p;
        const w = scheduleContainer.clientWidth - p;
        const s = Math.floor(Math.min((w - 50 * WEEKS_TO_SHOW - 20 * (WEEKS_TO_SHOW - 1)) / TOTAL_DAYS, (h - 40) / HOURS_PER_DAY)) - 2;
        document.documentElement.style.setProperty('--cell-size', `${s}px`);
    }
    
    function generateGrid() {
        scheduleWrapper.innerHTML = '';
        const today = new Date();
        const todayDayIndex = (today.getDay() + 6) % 7;
        const todayDate = today.getDate();
        const todayMonth = today.getMonth();

        const startMonday = new Date(today);
        startMonday.setDate(today.getDate() - todayDayIndex - DAYS_PER_WEEK);

        const weekDays = ['пн','вт','ср','чт','пт','сб','вс'];
        
        let allHourCells = [];

        for (let week = 0; week < WEEKS_TO_SHOW; week++) {
            const weekGrid = document.createElement('div');
            weekGrid.className = 'week-grid';
            
            weekGrid.appendChild(document.createElement('div'));

            for (let day = 0; day < DAYS_PER_WEEK; day++) {
                const dayHeader = document.createElement('div');
                const currentDate = new Date(startMonday);
                currentDate.setDate(startMonday.getDate() + (week * DAYS_PER_WEEK) + day);
                
                dayHeader.className = 'grid-cell day-header';
                if (currentDate.getDate() === todayDate && currentDate.getMonth() === todayMonth) {
                    dayHeader.classList.add('current-day');
                }
                dayHeader.innerHTML = `<span>${weekDays[day]}</span><span class="date-number">${currentDate.getDate()}</span>`;
                weekGrid.appendChild(dayHeader);
            }

            for (let hour = 0; hour < HOURS_PER_DAY; hour++) {
                const timeLabel = document.createElement('div');
                timeLabel.className = 'grid-cell time-label';
                timeLabel.textContent = `${hour.toString().padStart(2, '0')}:00`;
                weekGrid.appendChild(timeLabel);

                for (let day = 0; day < DAYS_PER_WEEK; day++) {
                    const hourCell = document.createElement('div');
                    hourCell.classList.add('hour-cell');
                    allHourCells.push(hourCell);
                    weekGrid.appendChild(hourCell);
                }
            }
            scheduleWrapper.appendChild(weekGrid);
        }
        addGridEventListeners(allHourCells);
    }
    
    function addGridEventListeners(hourCells) { 
        let isLmbDown = false; let isRmbDown = false; 
        scheduleWrapper.addEventListener('contextmenu', e => e.preventDefault()); 
        document.addEventListener('mousedown', e => { if (e.target.closest('.schedule-wrapper')) { if (e.button === 0) isLmbDown = true; else if (e.button === 2) isRmbDown = true; } }); 
        document.addEventListener('mouseup', () => { isLmbDown = false; isRmbDown = false; }); 
        
        hourCells.forEach(cell => { 
            cell.addEventListener('mousedown', e => { 
                e.preventDefault(); 
                if (activeView === '__MY_SCHEDULE__') { 
                    if (e.button === 0) cell.classList.add('selected'); 
                    else if (e.button === 2) cell.classList.remove('selected'); 
                } 
            }); 
            cell.addEventListener('mouseover', () => { 
                if (activeView === '__MY_SCHEDULE__') { 
                    if (isLmbDown) cell.classList.add('selected'); 
                    else if (isRmbDown) cell.classList.remove('selected'); 
                } 
            }); 
        }); 
    }

    function getShiftedScheduleState(scheduleBytes, hourShift) {
        const roundedHourShift = Math.round(hourShift);
        const scheduleStateArray = new Array(TOTAL_CELLS);

        for (let destIndex = 0; destIndex < TOTAL_CELLS; destIndex++) {
            const destWeek = Math.floor(destIndex / CELLS_PER_WEEK);
            const destIndexInWeek = destIndex % CELLS_PER_WEEK;
            const destHour = Math.floor(destIndexInWeek / DAYS_PER_WEEK);
            const destDayInWeek = destIndexInWeek % DAYS_PER_WEEK;
            const destAbsDay = destWeek * DAYS_PER_WEEK + destDayInWeek;
            const destAbsHour = destAbsDay * HOURS_PER_DAY + destHour;

            const sourceAbsHour = destAbsHour - roundedHourShift;

            if (sourceAbsHour < 0 || sourceAbsHour >= TOTAL_CELLS) {
                scheduleStateArray[destIndex] = 2; // 2 = Unknown
            } else {
                const sourceAbsDay = Math.floor(sourceAbsHour / HOURS_PER_DAY);
                const sourceHour = sourceAbsHour % HOURS_PER_DAY;
                const sourceWeek = Math.floor(sourceAbsDay / DAYS_PER_WEEK);
                const sourceDayInWeek = sourceAbsDay % DAYS_PER_WEEK;
                const sourceIndexInWeek = sourceHour * DAYS_PER_WEEK + sourceDayInWeek;
                const sourceIndex = sourceWeek * CELLS_PER_WEEK + sourceIndexInWeek;

                const isSourceBitSet = (scheduleBytes[Math.floor(sourceIndex / 8)] >> (sourceIndex % 8)) & 1;
                scheduleStateArray[destIndex] = isSourceBitSet ? 1 : 0; // 1 = Busy, 0 = Free
            }
        }
        return scheduleStateArray;
    }

    pasteBtn.addEventListener('click', async () => {
        try {
            const base64String = await navigator.clipboard.readText();
            const compressedData = binaryStringToUint8Array(atob(base64String));
            const decompressedStream = new Response(compressedData).body.pipeThrough(new DecompressionStream('gzip'));
            const payload = await new Response(decompressedStream).arrayBuffer();
            
            const dataView = new DataView(payload);
            const nickLength = dataView.getUint8(0);
            const senderOffsetMinutes = dataView.getInt16(1, true);
            const nickBytes = new Uint8Array(payload, 3, nickLength);
            const originalScheduleBytes = new Uint8Array(payload, 3 + nickLength);
            
            const nickname = new TextDecoder().decode(nickBytes);
            if (!nickname) { showFeedback("В данных отсутствует ник!", true); return; }

            if (originalScheduleBytes.length !== Math.ceil(TOTAL_CELLS / 8)) {
                showFeedback("Ошибка: формат данных не соответствует (ожидалось 3 недели)", true);
                return;
            }

            const senderOffsetHours = senderOffsetMinutes / 60;
            const newUser = { nickname, originalScheduleBytes, senderOffsetHours };
            
            const existingUserIndex = users.findIndex(u => u.nickname === nickname);
            if (existingUserIndex !== -1) {
                users[existingUserIndex] = newUser;
            } else {
                users.push(newUser);
            }
            activeView = nickname;
            if (users.length <= 2) overlapThreshold = 'all';
            render();
            showFeedback(`Данные для "${nickname}" вставлены!`);
        } catch (err) {
            console.error('Ошибка вставки:', err);
            showFeedback("Неверный формат данных!", true);
        }
    });

    copyBtn.addEventListener('click', async () => {
        try {
            if (activeView !== '__MY_SCHEDULE__') { showFeedback("Сначала перейдите в режим редактирования!", true); return; }
            const nickname = nicknameInput.value;
            if (!nickname) { showFeedback("Введите свой ник для копирования!", true); return; }
            
            const nickBytes = new TextEncoder().encode(nickname);
            if (nickBytes.length > 255) { showFeedback("Ник слишком длинный!", true); return; }
            
            const scheduleBytes = new Uint8Array(Math.ceil(TOTAL_CELLS / 8));
            scheduleWrapper.querySelectorAll('.hour-cell').forEach((cell, i) => { if (cell.classList.contains('selected')) { scheduleBytes[Math.floor(i/8)]|=(1<<(i%8)); } });

            const timezoneOffsetMinutes = parseFloat(timezoneSelect.value) * 60;
            
            const payload = new Uint8Array(1 + 2 + nickBytes.length + scheduleBytes.length);
            const dataView = new DataView(payload.buffer);
            
            dataView.setUint8(0, nickBytes.length);
            dataView.setInt16(1, timezoneOffsetMinutes, true);
            payload.set(nickBytes, 3);
            payload.set(scheduleBytes, 3 + nickBytes.length);

            const compressedStream = new Response(payload).body.pipeThrough(new CompressionStream('gzip'));
            const compressedData = await new Response(compressedStream).arrayBuffer();
            const base64String = btoa(Uint8ArrayToBinaryString(new Uint8Array(compressedData)));
            await navigator.clipboard.writeText(base64String);
            showFeedback("Скопировано в буфер обмена!");
        } catch (err) {
            console.error('Ошибка копирования:', err);
            showFeedback("Ошибка копирования!", true);
        }
    });
    
    let feedbackTimeout; function showFeedback(m,e=false){clearTimeout(feedbackTimeout);feedbackMessage.textContent=m;feedbackMessage.style.color=e?'#ff6b6b':'#aaa';feedbackMessage.classList.add('show');feedbackTimeout=setTimeout(()=>feedbackMessage.classList.remove('show'),3000);}
    function Uint8ArrayToBinaryString(u8a){let s='';u8a.forEach(b=>{s+=String.fromCharCode(b);});return s;} function binaryStringToUint8Array(s){const l=s.length;const u8a=new Uint8Array(l);for(let i=0;i<l;i++){u8a[i]=s.charCodeAt(i);}return u8a;}

    populateTimezoneSelector();
    generateGrid();
    resizeGrid();
    render();
    window.addEventListener('resize', resizeGrid);
});
</script>
</body>
</html>
